use log::error;
use serenity::{
  builder::CreateApplicationCommand,
  model::prelude::interaction::{
    application_command::ApplicationCommandInteraction, InteractionResponseType,
  },
  prelude::Context,
  Result as SerenityResult,
};

use crate::{bot::commands::CommandOutput, session::manager::SessionManager};

pub const NAME: &str = "leave";

async fn respond_message(
  ctx: &Context,
  command: &ApplicationCommandInteraction,
  msg: &str,
  ephemeral: bool,
) -> SerenityResult<()> {
  command
    .create_interaction_response(&ctx.http, |response| {
      response
        .kind(InteractionResponseType::ChannelMessageWithSource)
        .interaction_response_data(|message| message.content(msg).ephemeral(ephemeral))
    })
    .await
}

fn check_msg(result: SerenityResult<()>) {
  if let Err(why) = result {
    error!("Error sending message: {:?}", why);
  }
}

pub fn run(ctx: Context, command: ApplicationCommandInteraction) -> CommandOutput {
  Box::pin(async move {
    let data = ctx.data.read().await;
    let session_manager = data.get::<SessionManager>().unwrap().clone();

    let session = match session_manager.get_session(command.guild_id.unwrap()).await {
      Some(session) => session,
      None => {
        check_msg(
          respond_message(
            &ctx,
            &command,
            "I'm currently not connected to any voice channel",
            true,
          )
          .await,
        );
        return;
      }
    };

    if session.get_owner() != command.user.id {
      // This message was generated by AI, and I love it.
      check_msg(respond_message(&ctx, &command, "You are not the one who summoned me", true).await);
      return;
    };

    if let Err(why) = session.disconnect().await {
      error!("Error disconnecting from voice channel: {:?}", why);

      check_msg(
        respond_message(
          &ctx,
          &command,
          "An error occurred while disconnecting from the voice channel",
          true,
        )
        .await,
      );
      return;
    }

    check_msg(respond_message(&ctx, &command, "Successfully left the voice channel", false).await);
  })
}

pub fn register(command: &mut CreateApplicationCommand) -> &mut CreateApplicationCommand {
  command
    .name(NAME)
    .description("Request the bot to leave the current voice channel")
}
